diff --git a/sysdeps/zigux/include/zigux/syscall.h b/sysdeps/zigux/include/zigux/syscall.h
index d9f17d3..08e1b65 100644
--- a/sysdeps/zigux/include/zigux/syscall.h
+++ b/sysdeps/zigux/include/zigux/syscall.h
@@ -3,8 +3,18 @@
 
 #include <stdint.h>
 
-#define SYS_EXIT 60
-#define SYS_LOG 1024
+#define SYS_PROC_EXIT 0x0
+#define SYS_PROC_LOG 0x1
+
+#define SYS_FILE_OPEN 0x100
+#define SYS_FILE_CLOSE 0x101
+#define SYS_FILE_READ 0x102
+#define SYS_FILE_WRITE 0x103
+#define SYS_FILE_SEEK 0x104
+
+#define SYS_MEM_MAP 0x200
+#define SYS_MEM_UNMAP 0x201
+#define SYS_MEM_PROTECT 0x202
 
 #ifdef __cplusplus
 extern "C" {
@@ -129,5 +139,17 @@ inline uint64_t do_syscall(uint64_t n, T... a){
     return do_syscall(n, (uint64_t)(a)...);
 }
 
+inline int syscall_error(uint64_t ret) {
+    if((uint64_t)ret > -4096UL)
+        return -(int64_t)ret;
+
+    return 0;
+}
+
+template <typename T>
+inline T syscall_result(uint64_t res) {
+    return (int64_t)res;
+}
+
 #endif // __cplusplus
 #endif // _SYSCALL_H
diff --git a/sysdeps/zigux/src/sysdeps.cpp b/sysdeps/zigux/src/sysdeps.cpp
index f296181..45e4ea4 100644
--- a/sysdeps/zigux/src/sysdeps.cpp
+++ b/sysdeps/zigux/src/sysdeps.cpp
@@ -5,37 +5,110 @@
 #include <bits/off_t.h>
 #include <bits/ssize_t.h>
 #include <mlibc/fsfd_target.hpp>
+#include <mlibc/posix-sysdeps.hpp>
 #include <zigux/syscall.h>
 
-#define STUB_IMPL(name) { sys_libc_log("stub function " #name " was called"); sys_libc_panic(); }
+#define STUB_IMPL(name) { sys_libc_log("Stub function " #name " was called"); sys_libc_panic(); }
 
 namespace mlibc {
 
 [[noreturn]] void sys_exit(int code) {
-    do_syscall(SYS_EXIT, code);
+    do_syscall(SYS_PROC_EXIT, code);
 }
 
 void sys_libc_log(const char *message) {
-    do_syscall(SYS_LOG, message);
+    do_syscall(SYS_PROC_LOG, message);
 }
 
 [[noreturn]] void sys_libc_panic() {
-    sys_libc_log("mlibc panic :(");
     sys_exit(1);
 }
 
 int sys_tcb_set(void *pointer) STUB_IMPL(sys_tcb_set)
 int sys_futex_wait(int *pointer, int expected, const struct timespec *time) STUB_IMPL(sys_futex_wait)
 int sys_futex_wake(int *pointer) STUB_IMPL(sys_futex_wake)
-int sys_anon_allocate(size_t size, void **pointer) STUB_IMPL(sys_anon_allocate)
-int sys_anon_free(void *pointer, size_t size) STUB_IMPL(sys_anon_free)
-int sys_open(const char *pathname, int flags, int *fd) STUB_IMPL(sys_open)
-int sys_read(int fd, void *buf, size_t count, ssize_t *bytes_read) STUB_IMPL(sys_read)
-int sys_write(int fd, const void *buf, size_t count, ssize_t *bytes_written) STUB_IMPL(sys_write)
-int sys_seek(int fd, off_t offset, int whence, off_t *new_offset) STUB_IMPL(sys_seek)
-int sys_close(int fd) STUB_IMPL(sys_close)
-int sys_vm_map(void *hint, size_t size, int prot, int flags, int fd, off_t offset, void **window) STUB_IMPL(sys_vm_map)
-int sys_vm_unmap(void *pointer, size_t size) STUB_IMPL(sys_vm_unmap)
+
+int sys_anon_allocate(size_t size, void **pointer) {
+    return sys_vm_map(nullptr, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0, pointer);
+}
+
+int sys_anon_free(void *pointer, size_t size) {
+    return sys_vm_unmap(pointer, size);
+}
+
+int sys_open(const char *pathname, int flags, int *fd) {
+    auto res = do_syscall(SYS_FILE_OPEN, pathname, flags);
+
+    if (auto err = syscall_error(res))
+        return err;
+
+    *fd = syscall_result<int>(res);
+
+    return 0;
+}
+
+int sys_read(int fd, void *buf, size_t count, ssize_t *bytes_read) {
+    auto res = do_syscall(SYS_FILE_READ, fd, buf, count);
+
+    if (auto err = syscall_error(res))
+        return err;
+
+    *bytes_read = syscall_result<uint64_t>(res);
+
+    return 0;
+}
+
+int sys_write(int fd, const void *buf, size_t count, ssize_t *bytes_written) {
+    auto res = do_syscall(SYS_FILE_WRITE, fd, buf, count);
+
+    if (auto err = syscall_error(res))
+        return err;
+
+    *bytes_written = syscall_result<uint64_t>(res);
+
+    return 0;
+}
+
+int sys_seek(int fd, off_t offset, int whence, off_t *new_offset) {
+    auto res = do_syscall(SYS_FILE_SEEK, fd, offset, whence);
+
+    if (auto err = syscall_error(res))
+        return err;
+
+    *new_offset = syscall_result<uint64_t>(res);
+
+    return 0;
+}
+
+int sys_close(int fd) {
+    auto res = do_syscall(SYS_FILE_CLOSE, fd);
+
+    if (auto err = syscall_error(res))
+        return err;
+
+    return 0;
+}
+
+int sys_vm_map(void *hint, size_t size, int prot, int flags, int fd, off_t offset, void **window) {
+    auto res = do_syscall(SYS_MEM_MAP, hint, size, prot, flags, fd, offset);
+
+    if (auto err = syscall_error(res))
+        return err;
+
+    *window = (void*)syscall_result<uint64_t>(res);
+
+    return 0;
+}
+
+int sys_vm_unmap(void *pointer, size_t size) {
+    auto res = do_syscall(SYS_MEM_UNMAP, pointer, size);
+
+    if (auto err = syscall_error(res))
+        return err;
+
+    return 0;
+}
+
 int sys_clock_get(int clock, time_t *secs, long *nanos) STUB_IMPL(sys_clock_get)
 
 }
